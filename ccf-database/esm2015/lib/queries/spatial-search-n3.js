import { Euler } from '@math.gl/core';
import { OrientedBoundingBox } from '@math.gl/culling';
import { getMappedResult } from '../util/n3-functions';
import { ccf } from '../util/prefixes';
const spatialEntityDimensions = {
    [ccf.spatialEntity.x_dimension.id]: 'x',
    [ccf.spatialEntity.y_dimension.id]: 'y',
    [ccf.spatialEntity.z_dimension.id]: 'z'
};
function getSpatialEntityDimensions(store, iri) {
    const dims = getMappedResult(store, iri, 'Dimensions', spatialEntityDimensions);
    return [dims.x, dims.y, dims.z];
}
export function getOrientedBoundingBox(store, graph, sourceIri, targetIri) {
    const matrix = graph.getTransformationMatrix(sourceIri, targetIri);
    let result = undefined;
    if (matrix) {
        const center = matrix.getTranslation();
        const halfSize = getSpatialEntityDimensions(store, sourceIri).map(n => n / 1000 / 2);
        const quaternion = new Euler().fromRotationMatrix(matrix, Euler.XYZ).toQuaternion().normalize().calculateW();
        result = new OrientedBoundingBox().fromCenterHalfSizeQuaternion(center, halfSize, quaternion);
    }
    return result;
}
export function filterByProbingSphere(store, graph, seen, search) {
    const { x, y, z, radius, target } = search;
    const newSeen = new Set();
    const radiusSquared = (radius / 1000) * (radius / 1000);
    for (const sourceIri of seen) {
        const boundingBox = getOrientedBoundingBox(store, graph, sourceIri, target);
        if (boundingBox) {
            const distanceSquared = boundingBox.distanceSquaredTo([x, y, z].map(n => n / 1000));
            if (distanceSquared <= radiusSquared) {
                newSeen.add(sourceIri);
            }
        }
    }
    return newSeen;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhdGlhbC1zZWFyY2gtbjMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jY2YtZGF0YWJhc2Uvc3JjL2xpYi9xdWVyaWVzL3NwYXRpYWwtc2VhcmNoLW4zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFLdkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUd2QyxNQUFNLHVCQUF1QixHQUFHO0lBQzlCLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRztJQUN2QyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUc7SUFDdkMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHO0NBQ3hDLENBQUM7QUFFRixTQUFTLDBCQUEwQixDQUFDLEtBQVksRUFBRSxHQUFXO0lBQzNELE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBc0MsS0FBSyxFQUFFLEdBQUcsRUFBRSxZQUFZLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztJQUNySCxPQUFPLENBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUUsQ0FBQztBQUNwQyxDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEtBQVksRUFBRSxLQUFzQixFQUFFLFNBQWlCLEVBQUUsU0FBaUI7SUFDL0csTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLHVCQUF1QixDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNuRSxJQUFJLE1BQU0sR0FBb0MsU0FBUyxDQUFDO0lBQ3hELElBQUksTUFBTSxFQUFFO1FBQ1YsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sUUFBUSxHQUFHLDBCQUEwQixDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JGLE1BQU0sVUFBVSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUM3RyxNQUFNLEdBQUcsSUFBSSxtQkFBbUIsRUFBRSxDQUFDLDRCQUE0QixDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7S0FDL0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsTUFBTSxVQUFVLHFCQUFxQixDQUFDLEtBQVksRUFBRSxLQUFzQixFQUFFLElBQWlCLEVBQUUsTUFBcUI7SUFDbEgsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDM0MsTUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztJQUNsQyxNQUFNLGFBQWEsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQztJQUN4RCxLQUFLLE1BQU0sU0FBUyxJQUFJLElBQUksRUFBRTtRQUM1QixNQUFNLFdBQVcsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM1RSxJQUFJLFdBQVcsRUFBRTtZQUNmLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDcEYsSUFBSSxlQUFlLElBQUksYUFBYSxFQUFFO2dCQUNwQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ3hCO1NBQ0Y7S0FDRjtJQUNELE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdWxlciB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuaW1wb3J0IHsgT3JpZW50ZWRCb3VuZGluZ0JveCB9IGZyb20gJ0BtYXRoLmdsL2N1bGxpbmcnO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICd0cmlwbGUtc3RvcmUtdXRpbHMnO1xuXG5pbXBvcnQgeyBDQ0ZTcGF0aWFsR3JhcGggfSBmcm9tICcuLi9jY2Ytc3BhdGlhbC1ncmFwaCc7XG5pbXBvcnQgeyBTcGF0aWFsU2VhcmNoIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBnZXRNYXBwZWRSZXN1bHQgfSBmcm9tICcuLi91dGlsL24zLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBjY2YgfSBmcm9tICcuLi91dGlsL3ByZWZpeGVzJztcblxuXG5jb25zdCBzcGF0aWFsRW50aXR5RGltZW5zaW9ucyA9IHtcbiAgW2NjZi5zcGF0aWFsRW50aXR5LnhfZGltZW5zaW9uLmlkXTogJ3gnLFxuICBbY2NmLnNwYXRpYWxFbnRpdHkueV9kaW1lbnNpb24uaWRdOiAneScsXG4gIFtjY2Yuc3BhdGlhbEVudGl0eS56X2RpbWVuc2lvbi5pZF06ICd6J1xufTtcblxuZnVuY3Rpb24gZ2V0U3BhdGlhbEVudGl0eURpbWVuc2lvbnMoc3RvcmU6IFN0b3JlLCBpcmk6IHN0cmluZyk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIGNvbnN0IGRpbXMgPSBnZXRNYXBwZWRSZXN1bHQ8eyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0+KHN0b3JlLCBpcmksICdEaW1lbnNpb25zJywgc3BhdGlhbEVudGl0eURpbWVuc2lvbnMpO1xuICByZXR1cm4gWyBkaW1zLngsIGRpbXMueSwgZGltcy56IF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmllbnRlZEJvdW5kaW5nQm94KHN0b3JlOiBTdG9yZSwgZ3JhcGg6IENDRlNwYXRpYWxHcmFwaCwgc291cmNlSXJpOiBzdHJpbmcsIHRhcmdldElyaTogc3RyaW5nKTogT3JpZW50ZWRCb3VuZGluZ0JveCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IG1hdHJpeCA9IGdyYXBoLmdldFRyYW5zZm9ybWF0aW9uTWF0cml4KHNvdXJjZUlyaSwgdGFyZ2V0SXJpKTtcbiAgbGV0IHJlc3VsdDogT3JpZW50ZWRCb3VuZGluZ0JveCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgaWYgKG1hdHJpeCkge1xuICAgIGNvbnN0IGNlbnRlciA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuICAgIGNvbnN0IGhhbGZTaXplID0gZ2V0U3BhdGlhbEVudGl0eURpbWVuc2lvbnMoc3RvcmUsIHNvdXJjZUlyaSkubWFwKG4gPT4gbiAvIDEwMDAgLyAyKTtcbiAgICBjb25zdCBxdWF0ZXJuaW9uID0gbmV3IEV1bGVyKCkuZnJvbVJvdGF0aW9uTWF0cml4KG1hdHJpeCwgRXVsZXIuWFlaKS50b1F1YXRlcm5pb24oKS5ub3JtYWxpemUoKS5jYWxjdWxhdGVXKCk7XG4gICAgcmVzdWx0ID0gbmV3IE9yaWVudGVkQm91bmRpbmdCb3goKS5mcm9tQ2VudGVySGFsZlNpemVRdWF0ZXJuaW9uKGNlbnRlciwgaGFsZlNpemUsIHF1YXRlcm5pb24pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJCeVByb2JpbmdTcGhlcmUoc3RvcmU6IFN0b3JlLCBncmFwaDogQ0NGU3BhdGlhbEdyYXBoLCBzZWVuOiBTZXQ8c3RyaW5nPiwgc2VhcmNoOiBTcGF0aWFsU2VhcmNoKTogU2V0PHN0cmluZz4ge1xuICBjb25zdCB7IHgsIHksIHosIHJhZGl1cywgdGFyZ2V0IH0gPSBzZWFyY2g7XG4gIGNvbnN0IG5ld1NlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgcmFkaXVzU3F1YXJlZCA9IChyYWRpdXMgLyAxMDAwKSAqIChyYWRpdXMgLyAxMDAwKTtcbiAgZm9yIChjb25zdCBzb3VyY2VJcmkgb2Ygc2Vlbikge1xuICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gZ2V0T3JpZW50ZWRCb3VuZGluZ0JveChzdG9yZSwgZ3JhcGgsIHNvdXJjZUlyaSwgdGFyZ2V0KTtcbiAgICBpZiAoYm91bmRpbmdCb3gpIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IGJvdW5kaW5nQm94LmRpc3RhbmNlU3F1YXJlZFRvKFt4LCB5LCB6XS5tYXAobiA9PiBuIC8gMTAwMCkpO1xuICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA8PSByYWRpdXNTcXVhcmVkKSB7XG4gICAgICAgIG5ld1NlZW4uYWRkKHNvdXJjZUlyaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdTZWVuO1xufVxuIl19